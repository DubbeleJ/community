interface IA {
	in void init();		// activate super statemachine
	in void ssm1();		// start of sub statemachine 1
	in void ssm2();		// start of sub statemachine 2
	in void subnext();	// step in sub statemachine *
	out void substep(); // some reporting back of sub state machine progress
	
	behaviour {
		enum State {Off, Idle, Busy};
		State state = State.Off;
		
		[state.Off] {
			on init: {state = State.Idle;}
			on ssm1, ssm2, subnext: illegal;
		}
		[state.Idle] {
			on init: illegal;
			on ssm1: {state = State.Busy;}
			on ssm2: {state = State.Busy;}
			on subnext: illegal;
		}
		[state.Busy] {
			on init: illegal;
			on subnext:{state = State.Off;}
			on subnext:{state = State.Idle;}
			on subnext: substep;	
			on ssm1, ssm2: illegal;
		}
	}
}

// 'internal' sub state machine interface
interface IReflector {
	in void forward();
	in void exit();
	out void entry();
	out void back();
	
	behaviour {
		on forward: entry;
		on exit: back;
	}
}

component SSMPattern {
	provides IA ia;
	requires IReflector iReflector;
	
	behaviour {
		enum State {Off, Idle, Busy}; // super state machine states
		enum Submachine {One, Two};	// to keep track which sub state machine is active
		enum Substate {a, b};		// used by both sub state machines
		enum RetValue {ok, nok};	// pass value back from sub- to super-SM
		State state = State.Off;
		Submachine submachine = Submachine.One;
		Substate substate = Substate.a;
		RetValue retvalue = RetValue.nok;
		
		[state.Off] {
			on ia.init(): {state = State.Idle;}
//			on iReflector.back(): {}
			
		}		
		[state.Idle] {
			on ia.ssm1(): {state = State.Busy; submachine = Submachine.One; iReflector.forward();}
			on ia.ssm2(): {state = State.Busy; submachine = Submachine.Two; iReflector.forward();}
		}
		[state.Busy] {
			on iReflector.back(): {
				if (retvalue == RetValue.ok) // use return value from substate machine
					state = State.Idle; 
				else 
					state = State.Off; 
			}
		}
		
		//sub state machine1
		[state.Busy && submachine.One] { 
			on iReflector.entry(): {substate = Substate.a;}
			[substate.a] {
				on ia.subnext(): {
					ia.substep();
					substate = Substate.b;
				}
			}
			[substate.b] {
				on ia.subnext(): {
					retvalue = RetValue.ok; // pass value to super state machine
					substate = Substate.a;  // deep/shallow but also done at entry
					iReflector.exit();
				}
			}	 
		}
		
		//sub state machine2
		[state.Busy && submachine.Two] { 
			on iReflector.entry(): {substate = Substate.a;}
			[substate.a] {
				on ia.subnext(): {
					ia.substep();
					substate = Substate.b;
				}
			}
			[substate.b] {
				on ia.subnext(): {
//					state = State.Off; 
					retvalue = RetValue.nok; // pass value to super state machine
					substate = Substate.a;   // deep/shallow but also done at entry
					iReflector.exit();
				}
			}			 
		}		
	}
}

component Reflector {
	provides IReflector iReflector;
	
	behaviour {
		on iReflector.forward(): iReflector.entry();
		on iReflector.exit(): iReflector.back();		
	}
}

/*
 * substate machine could also change the state of the superstate machine directly as
 * shown (commented out) in line 106. Note that then the iReflector.back arrives in the state.Off
 * and needs to be caught there hence the (commented out) statement in line 61
 * In that solution the complex mechanism to pass back a value to the superstate machine is superfluous
 */
